
import numpy as np
from reaff import get_reaff
from model_support import *



################################################################
##	GEOMETRIC PARAMETERS

# values from CAD_review/Frames
WHISKY_LOC_LIFT_X = 0.12865
WHISKY_LOC_LIFT_Y = 0.0
WHISKY_LOC_LIFT_Z = 0.07985

# values arbitrary
WHISKY_LIFT_INI_RAD = np.radians(-45.0)
WHISKY_LIFT_MIN_RAD = np.radians(-60.0)
WHISKY_LIFT_MAX_RAD = np.radians(-30.0)

# values from CAD_review/Frames
WHISKY_LOC_PITCH_X = 0.24733
WHISKY_LOC_PITCH_Y = 0.0
WHISKY_LOC_PITCH_Z = -0.03100

# values arbitrary
WHISKY_PITCH_INI_RAD = np.radians(45.0)
WHISKY_PITCH_MIN_RAD = np.radians(15.0)
WHISKY_PITCH_MAX_RAD = np.radians(75.0)

# values from CAD_review/Frames
WHISKY_LOC_YAW_X = 0.10381
WHISKY_LOC_YAW_Y = 0.0
WHISKY_LOC_YAW_Z = 0.02250

# values arbitrary
WHISKY_YAW_INI_RAD = np.radians(0.0)
WHISKY_YAW_MIN_RAD = np.radians(-45.0)
WHISKY_YAW_MAX_RAD = np.radians(45.0)



################################################################
##	DEFINITION OF HEADSPACE

def find_nearest(array, value):
	return (np.abs(array-value)).argmin()

def get_range(i, L, N):
	return range(max(0, i-L), min(N, i+L+1))

class HeadSpace:

	def lim2range(self, lim, step):

		if -lim[0] == lim[1]:
			xx = np.arange(0, lim[1]+1e-9, step)
			return np.concatenate((-xx[:0:-1], xx))
		else:
			return np.arange(lim[0], lim[1]+1e-9, step)

	def __init__(self, xlim, ylim, zlim, step):

		self.xlim = xlim;
		self.ylim = ylim;
		self.zlim = zlim;
		self.step = step;

		self.xx = self.lim2range(xlim, step)
		self.yy = self.lim2range(ylim, step)
		self.zz = self.lim2range(zlim, step)

		self.shape = [len(self.xx), len(self.yy), len(self.zz)]
		self.numel = np.prod(self.shape)
		self.xi_cen = int(float(self.shape[0]) / 2 + 0.5)
		self.yi_cen = int(float(self.shape[1]) / 2 + 0.5)
		self.zi_cen = int(float(self.shape[2]) / 2 + 0.5)

		self.xii = range(0, self.shape[0])
		self.yii = range(0, self.shape[1])
		self.zii = range(0, self.shape[2])

	def createMap(self):
		mapval = np.zeros(self.shape, dtype='float32')
		shape = self.shape[:]
		shape.append(3)
		mappos = np.zeros(shape)
		for xi in range(0, self.shape[0]):
			for yi in range(0, self.shape[1]):
				for zi in range(0, self.shape[2]):
					mappos[xi, yi, zi] = np.array([self.xx[xi], self.yy[yi], self.zz[zi]])
		return (mappos, mapval)

	def getRanges(self, pos, L):

		# find best match
		xi = find_nearest(self.xx, pos[0])
		yi = find_nearest(self.yy, pos[1])
		zi = find_nearest(self.zz, pos[2])

		# generate range
		xii = get_range(xi, L, self.shape[0])
		yii = get_range(yi, L, self.shape[1])
		zii = get_range(zi, L, self.shape[2])

		return (xii, yii, zii)



################################################################
##	SYSTEM PARAMETERS OBJECT

class SystemPars:

	def __init__(self):

		# ROS
		self.topic_root = '/model'

		# time
		self.fS_lo = 50
		self.fS_hi = 500
		self.fS_scale = self.fS_hi / self.fS_lo

		# platform geometry
		self.shape_lo = [6, 4]
		self.shape_lo_2 = [6, 4, 2]
		self.shape_hi = self.shape_lo[:]
		self.shape_hi.insert(0, self.fS_scale)
		self.shape_hi_2 = self.shape_lo_2[:]
		self.shape_hi_2.insert(0, self.fS_scale)
		self.frame_HEAD = 3

		# helpers for that
		self.rows = range(0, self.shape_lo[0])
		self.cols = range(0, self.shape_lo[1])
		self.dims = [0, 1]

		# platform physical dimensions
		self.theta_range = np.radians([-60, 60])
		self.fovea_HEAD = np.array([0.200, 0.0, -0.040])
		self.virtual_floor_z = 0.15
		#### GENERATED BY import_frames ####
		rows = []
		rows.append([1.738770, 0.785273, -0.000431, 0.153000, -0.044180, -0.049210])
		rows.append([1.198414, 0.785372, -0.000056, 0.162080, -0.034240, -0.015910])
		rows.append([0.399329, 0.785354, 0.000124, 0.170930, -0.004290, 0.000350])
		rows.append([-0.399372, 0.785336, -0.000038, 0.170930, 0.028250, -0.009760])
		rows.append([-1.198430, 0.785386, 0.000084, 0.162080, 0.043700, -0.040130])
		rows.append([-1.745256, 0.785393, -0.000047, 0.152720, 0.040060, -0.074570])
		self.row_boards = rows
		whiskers = []
		whiskers.append([0.083095, -0.017500, -0.015765, 0.016800])
		whiskers.append([0.025007, -0.035500, -0.014535, 0.017220])
		whiskers.append([-0.025007, -0.053500, -0.013755, 0.017120])
		whiskers.append([-0.075047, -0.071490, -0.013005, 0.016480])
		self.whiskers = whiskers
		self.whisker_length = [0.060360, 0.081010, 0.111480, 0.171700]
		#### GENERATED BY import_frames ####

		# reafferent noise model parameters
		reaff_ = get_reaff()
		reaff = create_empty_array_of_shape(self.shape_lo_2)
		i = 0
		for row in self.rows:
			for col in self.cols:
				for dim in self.dims:
					reaff[row][col][dim] = reaff_[i]
					i += 1
		self.reaff = np.array(reaff)

		# contact belief threshold should be set to just clear of
		# the free-whisking noise floor for each column
		contact_thresh = [0.04, 0.04, 0.04, 0.04]
		self.contact_thresh = np.transpose(np.tile(np.transpose([contact_thresh]), self.shape_lo[0]))

		# contact belief gain is a per-column parameter, for now we
		# just set it to the same across all columns - a sensible
		# value would be between 1 and 10, say.
		self.contact_gain = 5.0 # * np.ones(self.shape_lo)

		# spatial pars
		self.headspace = HeadSpace([0, 0.4], [-0.35, 0.35], [-0.35, 0.25], 0.025)
		#self.headspace = HeadSpace([0, 0.25], [-0.25, 0.25], [-0.15, 0.25], 0.04)
		self.salience_macon_width = 0.05
		self.salience_discard = 0.01 # saliences below this fraction are discarded computationally
		self.salience_decay_tau = 1.0
		self.noise_decay_tau = 1.0
		self.noise_spatial_sigma = 1.0
		self.noise_magnitude = 0.1
		self.sausage_cen_x_offset = 0.15
		self.sausage_rad = 0.25
		self.sausage_heightAboveFloor = 0.15
		self.sausage_var_shell = 0.1
		self.sausage_var_height = 0.25

		# action pars
		self.pri_idle = 0.25
		self.pri_ongoing = 0.75
		self.orient_min_time = 0.5
		self.orient_max_speed = 0.2
		self.orient_shimmy_speed = 0.0 #1.0

		# whisking pars
		self.fW = 2.0





